<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>http://localhost:4000</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <description></description>
    <language>en-us</language>
    <pubDate>Tue, 20 Jun 2017 22:32:39 +0800</pubDate>
    <lastBuildDate>Tue, 20 Jun 2017 22:32:39 +0800</lastBuildDate>

    
      <item>
        <title>positive matrix</title>
        <link>http://localhost:4000/positive-matrix</link>
        <pubDate>Tue, 20 Jun 2017 00:00:00 +0800</pubDate>
        <author></author>
        <description>
&lt;p&gt;Property of positive matrix \(A\)&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;(1) The spectral radius \(\rho (A)\) is an eigenvalue of A; the geometric and algebraic multiplicity is 1. (Let \(\sigma(A)\) be the set consisted of \(A\)’s eigenvalues, then \(\rho(A) = \max_{\lambda\in\sigma(A)}|\lambda|\).)&lt;/p&gt;

&lt;p&gt;(2) The eigenvector \(x\) associated with the eigenvalue \(\rho (A)\) can be taken to have nonnegative entries; other eigenvectors cannot be taken to have nonnegative entries!&lt;/p&gt;

&lt;p&gt;(3) If every entry of \(A\) is positive, then \(\rho(A)\) is a simple eigenvalue, that is strictly larger than the modulus of any other eigenvalues.&lt;/p&gt;

&lt;p&gt;(4) If every entry of \(A\) is positive, then \(\lim_{m\to\infty}(\frac{A}{\rho(A)})^m\) exists and is a rank-one matrix; each of whose columns is proportional to the eigenvector x.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Corollary&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Let \(x\) be \(A\)’s P-F vector, i.e. \(Ax=\rho(A)x\). \(y\) be its left P-F vector, i.e.\(y^TA=\rho(A)y^T\), and they normalized to 1, i.e. \(x^Ty=1\). Then&lt;/p&gt;

&lt;p&gt;\[\lim_{m\to\infty}(\frac{A}{\rho(A)})^m=xy^T\]&lt;/p&gt;

&lt;p&gt;proof:&lt;/p&gt;

&lt;p&gt;Exist \(S=(x, S’), (S^{-1})^T=(y, Z’)\), such that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
(\frac{A}{\rho(A)})^m =S
\begin{pmatrix}
1&amp;0\\
0&amp;(\rho(A)^{-1}B)^m
\end{pmatrix}
S^{-1}\\
\to(x, S')
\begin{pmatrix}
1&amp;0\\
0&amp;0_{n-1}
\end{pmatrix}
\begin{pmatrix}
y^T\\Z'^T
\end{pmatrix}=xy^T , \quad m\to \infty %]]&gt;&lt;/script&gt;

&lt;p&gt;(5) There is a unique vector \(x=[x_i]\in C^n\) such that \(Ax=\rho(A)x \) and \(\sum_ix_i=1\). Such a vector must be positive.&lt;/p&gt;

&lt;h1 id=&quot;nonnegative-matrix&quot;&gt;Nonnegative matrix&lt;/h1&gt;

&lt;p&gt;properties:&lt;/p&gt;

&lt;p&gt;(1) Let \(A, B \in M_n\) and suppose that B is nonnegative. If \(|A|\le B\) (the absolute, not determinant), then \(\rho(A)\le\rho(|A|)\le \rho(B)\).&lt;/p&gt;

&lt;p&gt;(2) Let \(A=[a_{ij}]\in M_n\) br nonnegative. Then&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{1\le i\le n}\sum_{j=1}^na_{ij}\le\rho(A)\le\max_{1\le i\le n}\sum_{j=1}^{n}a_{ij}&lt;/script&gt;

&lt;p&gt;The spectral radius of \(A\) is bounded by the minimum row sum and the maximum row sum. Similarly, \(\rho(A)\) is bounded by the minimum column sum and maximum column sum.&lt;/p&gt;

&lt;p&gt;proof:&lt;/p&gt;

&lt;p&gt;The definition of the matrix norm is given by:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\|A\|_p=\max_{\|x\|_p=1}\|Ax\|_p, \quad \|x\|_p=(\sum_{i=1}^nx_i^p)^{1/p}&lt;/script&gt;

&lt;p&gt;The general norm is given by Cauchy-Schwartz theorem.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\|A\|\cdot \|x\|\ge \|Ax\|, \quad
\|A\|\ge\frac{\|Ax\|}{\|x\|}&lt;/script&gt;

&lt;p&gt;Specifically, we have:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\|A\|_1=\max_{1\le j\le n}\sum_{i=1}^n|a_{ij}|\\
\|A\|_{\infty}=\max_{1\le i\le n}\sum_{i=1}^n|a_{ij}|\\&lt;/script&gt;

&lt;p&gt;Lemma: The eigenvalues of matrix A is no larger than the matrix norm, i.e. \(|\lambda|\le\|A\|\)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Ax=\lambda x\\
|\lambda|\cdot\|x\|=\|Ax\|\le\|A\|\cdot\|x\|\\&lt;/script&gt;

&lt;p&gt;The left inequality can be demonstrated this way.&lt;/p&gt;

&lt;p&gt;Let \(\alpha=\min_{1\le i\le n}\sum_{j=1}^na_{ij}\). Define \(B=[b_{ij}]\), and \(b_{ij}=\alpha a_{ij}(\sum_{k=1}^na_{ik})^{-1}\). Then \(A\ge B\ge 0\), i.e. \(\rho(A)\ge \rho(B)\) and \(\sum_{j=1}^nb_{ij}=\alpha\) for all \(i=1,\cdots,n\), i.e. \(\rho(B)=\alpha\). Therefore,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{1\le i\le n}\sum_{j=1}^na_{ij}\le\rho(A)&lt;/script&gt;

&lt;p&gt;(3) If \(A\in M_n\) is nonnegative, for nonnegative \(x\):&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\rho(A)=\max_{x\ge 0}\min_{1\le i\le n}\frac{(Ax)_i}{x_i}&lt;/script&gt;

&lt;p&gt;proof:&lt;/p&gt;

&lt;p&gt;From (2), 
&lt;script type=&quot;math/tex&quot;&gt;\rho(A)\ge \min_{1\le u\le n}(Ax)_i/x_i.&lt;/script&gt;
The maximum can be obtained when \(x\) satisfies \(Ax=\rho(A)x\)&lt;/p&gt;

&lt;p&gt;(4) Suppose there is a positive vector \(x\) and a nonnegative real number \(\lambda\) such that either \(Ax=\lambda x\) or \(x^TA=\lambda x^T\). Then \(\lambda = \rho(A)\).&lt;/p&gt;

&lt;p&gt;proof:&lt;/p&gt;

&lt;p&gt;Suppose x is the corresponding eigenvector of \(\lambda\), y is the left eigenvector of \(\rho(A)\), then.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Ax=\lambda x, \quad y^TA=\rho(A)y^T\\
\rho(A)y^Tx=y^TAx=\lambda y^Tx\\Thus\quad \rho(A)=\lambda.&lt;/script&gt;

</description>
      </item>
    
      <item>
        <title>Incidence Matrix</title>
        <link>http://localhost:4000/Incidence-Matrix</link>
        <pubDate>Sun, 18 Jun 2017 00:00:00 +0800</pubDate>
        <author></author>
        <description>&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;

&lt;p&gt;(此定义不唯一) 每一行代表一条边, 每一列代表一个顶点, 在表征任意一条边的一行, 如果这条边从\(i\)出发,到达\(j\), 则给第\(i\)个元素赋-1, 第\(j\)个赋1, 其他赋0.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;性质一&quot;&gt;性质一&lt;/h3&gt;

&lt;p&gt;\(G=(V,E)\)为有向连通图 (只需任意顶点间有边相连), A为G的关联矩阵, 且\(|V|=n\), 则\(dimN(A)=1\).&lt;/p&gt;

&lt;p&gt;若\(i,j\)相邻,则\(x_i=x_j=1\). 由邻接的传递性, 由G为连通图, 可知任意两点\(p,q\)均连通, 即\(x_p=x_q=1\).&lt;/p&gt;

&lt;h3 id=&quot;推论&quot;&gt;推论&lt;/h3&gt;

&lt;p&gt;\(G=(V,E)\)有\(k\)个连通分支, 则\(dimN(A)=k\).&lt;/p&gt;

&lt;p&gt;将矩阵\(A\)重新排成\(k\)个分块对角矩阵的形式, 即\(A=diag(A_1,A_2,\cdots,A_k)\)&lt;/p&gt;

&lt;p&gt;则对每一个分块矩阵,内部连通,其零空间维数皆为1.&lt;/p&gt;

&lt;p&gt;研究方程\(Ax=b\)的解, 从A的四个基本子空间入手.&lt;/p&gt;

&lt;h3 id=&quot;na&quot;&gt;\(N(A)\)&lt;/h3&gt;

&lt;p&gt;令\(b\)为边上的电势差. 每个节点等电位, 就是使\(b=0\)的条件.&lt;/p&gt;

&lt;h3 id=&quot;ca&quot;&gt;\(C(A)\)&lt;/h3&gt;

&lt;p&gt;任意给定节点电位, 得到边上电势降的所有情况就组成了列空间. \(KVL\)定律给出了对边上电势降的约束, 即任意环路上电势降代数和为零. 因此独立环路的个数就是对列空间约束的自由度的数目.&lt;/p&gt;

&lt;p&gt;对于m条边, n个顶点的连通图, 独立环路的个数为\(m-n+1\).* 因此, 列空间的自由度数目为\(m-(m-n+1)=n-1\), 即为A的秩.&lt;/p&gt;

&lt;h3 id=&quot;nat&quot;&gt;\(N(A^T)\)&lt;/h3&gt;

&lt;p&gt;左零空间是使节点处电流代数和为零的边上电流所组成的空间, 由\(KCL\)约束. 总共有\(n\)个节点, 而独立的节点方程个数只有\(n-1\)个, 因此其维度为\(m-(n-1)=m-n+1\)与C(A)互为\(R^m\)的正交补.&lt;/p&gt;

&lt;p&gt;左零空间为C(A)关于\(R^m\)的正交补, 因此垂直于由独立环路约束所确定的超平面. 其物理意义为不存在外加电源时的解.&lt;/p&gt;

&lt;h3 id=&quot;cat&quot;&gt;\(C(A^T)\)&lt;/h3&gt;

&lt;p&gt;Rows are dependent when edges form a loop. Independent rows come from a tree. 因此行空间的基可通过选取该图的一个生成树获得. 通过与N(A)的正交补性质可快速判断.&lt;/p&gt;

&lt;p&gt;任意给定边上的电流, 得到节点的电流代数和的所有情况组成行空间. 没有外界电流输入的节点, 电流代数和为零, 所有节点总的电流代数和应该为0.(电流连续性)&lt;/p&gt;

&lt;h3 id=&quot;综上所述&quot;&gt;综上所述&lt;/h3&gt;

&lt;p&gt;\(N(A^T)\)的基可通过m-n+1个独立环路构造(m维);&lt;/p&gt;

&lt;p&gt;\(C(A^T)\)的基可通过生成子树的n-1条边构造(n维);&lt;/p&gt;

&lt;p&gt;\(C(A)\)的基可通过n-1个独立节点来构造(m维);&lt;/p&gt;

&lt;p&gt;\(N(A)\)的基就是\(\vec{e}\), 可通过对每个节点整体提升电势构造(n维).&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>How does FFT work?</title>
        <link>http://localhost:4000/How-does-FFT-work</link>
        <pubDate>Thu, 15 Jun 2017 00:00:00 +0800</pubDate>
        <author></author>
        <description>
&lt;p&gt;Let’s first start with DFT (Discrete Fourier Transform)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{bmatrix}
y_1\\\
y_2\\\
y_3\\\
\vdots\\\
y_n
\end{bmatrix}=
\begin{bmatrix}
1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 \\\
1 &amp;  \omega &amp; \omega^2 &amp;\cdots &amp; \omega^{n-1} \\\
1 &amp; \omega^2 &amp; \omega^4 &amp; \cdots &amp; \omega^{2n-2} \\\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\\
1 &amp; \omega^{n-1} &amp;\omega^{2n-2} &amp; \cdots &amp; \omega^{(n-1)^2}
\end{bmatrix}
\begin{bmatrix}
c_1\\\
c_2\\\
c_3\\\
\vdots\\\
c_n
\end{bmatrix},\quad \omega=e^{\frac{2\pi i}{n}} %]]&gt;&lt;/script&gt;

&lt;!--more--&gt;

&lt;p&gt;The vector \(y\) is the function to be expanded and the matrix multiplied by the coefficients \(c\) is the Fourier matrix \(F_n\); it is seen in &lt;em&gt;frequency space&lt;/em&gt; through the coefficients \(c_k\). This formula is actually called the inverse Fourier transform. It can be seen from \(\omega\)(it has positive sign on \(\omega\)). Fourier transform is the one that computes the frequency expansion given the function value at each time step.&lt;/p&gt;

&lt;p&gt;Compare to the continuous form of Fourier transform:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(t)=\int_{-\infty}^{+\infty}F(\nu)e^{2\pi i\nu t}d\nu&lt;/script&gt;

&lt;p&gt;In the case of n order Fourier matrix, we have to compute&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y_j=\sum_{k=0}^{n-1}\omega^{jk}x_k, \quad j=0,1,\cdots,n-1&lt;/script&gt;

&lt;p&gt;The complexity is \(O(n^2)\). The idea of FFT is to recursively compute the half size matrix (i.e. \(F_{n/2}, F_{n/4}, \cdots\)) and the complexity can be reduced to \(O(nlog(n))\).
The link between the origin matrix and its half sized counterpart is the property of complex number. Suppose \(m=\frac{n}{2}\), then \(\omega_m=\omega_n^2\) (It’s easy to see, since the m-order unit roots separate the unit circle into m parts.) 
For the first m entries of \(y\), we split the sum into even and odd parts.
\[y_j=\sum_{k=0}^{n-1}\omega_n^{jk}c_k=\sum_{k=0}^{n/2-1}\omega_n^{2jk}c_{2k}+\sum_{k=0}^{n/2-1}\omega_n^{j(2k+1)}c_{2k+1}, \quad j=0,1,\cdots, n/2-1\]
The even c’s go into \(c’=(c_0,c_2,\cdots)\) and the odd c’s go into \(c’’=(c_1,c_3,\cdots)\). Set \(y’=F_mc’,y’'=F_mc’’\). Then using \(\omega_m=\omega_n^2\), we can transform it into the combintion of \(y’ and y’’\).&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;LHS=\sum_{k=0}^{m-1}\omega_m^{jk}c'_k + \omega_n^j \sum_{k=0}^{m-1}\omega_m^{jk}c''_k=y'_j+(\omega_n)^jy''_j&lt;/script&gt;

&lt;p&gt;For \(j\ge m\), Noticing that \(\omega_n^m=-1\) we have:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{equation} 
\begin{split}
y_{j+m} &amp; = \sum_{k=0}^{n-1}\omega_n^{(j+m)k}c_{k} \\
&amp; = \sum_{k=0}^{n/2-1}(-1)^{2k}\omega_n^{2jk}c_{2k}+\sum_{k=0}^{n/2-1}(-1)^{(2k+1)}\omega_n^{j(2k+1)}c_{2k+1} \\
&amp; =\sum_{k=0}^{m-1}\omega_m^{jk}c'_k - \omega_n^j \sum_{k=0}^{m-1}\omega_m^{jk}c''_k \\
&amp; = y'_j - (\omega_n)^j y''_j 
\end{split}
\end{equation} %]]&gt;&lt;/script&gt;

&lt;p&gt;So here we are, the essential expansion in this recursion.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{align}
y_j=y'_j+\omega_n^jy''_j, \quad j=0,1,\cdots,m-1 \\
y_{j+m}=y'_j-\omega_n^jy''_j, \quad j=0,1,\cdots,m-1
\end{align}&lt;/script&gt;

&lt;p&gt;The equations can be written in matrix expression.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
y=
\begin{bmatrix}
I_m &amp; D_m \\
I_m &amp; -D_m
\end{bmatrix}
\begin{bmatrix}
y'\\
y''
\end{bmatrix}, \quad D_m=diag(1,\omega,\cdots, \omega^{m-1}) %]]&gt;&lt;/script&gt;

&lt;p&gt;Remember the definition of \(y’ and y’’\).&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{bmatrix}
y'\\y''
\end{bmatrix}=
\begin{bmatrix}
F_m &amp;O\\
O&amp;F_m
\end{bmatrix}
\begin{bmatrix}
c'\\c''
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;We are nearly there; the last matrix is an ‘even-odd’ permutation that separates the incoming vector \(c\) into its even and odd parts \(c’=(c_0,c_2,\cdots,c_{n-2}) and c’’=(c_1, c_3,\cdots,c_{n-1})\). For a direct look, we give the example of a 4-order even-odd permutation matrix:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
P_4=\begin{bmatrix}
1 &amp;&amp;&amp;\\
&amp;&amp;1&amp;\\
&amp;1&amp;&amp;\\
&amp;&amp;&amp;1
\end{bmatrix} %]]&gt;&lt;/script&gt;

&lt;p&gt;So one recursion of the FFT can be written as the multiplication of three matrix.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
F_n=
\begin{bmatrix}
I_n/2 &amp; D_n/2 \\
I_n/2 &amp; -D_n/2
\end{bmatrix}
\begin{bmatrix}
F_n/2&amp;O\\
O&amp; F_n/2
\end{bmatrix}
P_n %]]&gt;&lt;/script&gt;

&lt;p&gt;The whole algorithm will iteratively compute \(log_2(n)\) stages until it reaches the bottom. In each stage, The only computation is the multiplication between the diagonal matrix and the half sized Fourier matrix, which is \(\frac{n}{2}\) times of multiplications. So the complexity of the whole algorithm will be \(\frac{1}{2}nlog_2n\) .&lt;/p&gt;

&lt;p&gt;As for the multiplication of the permutation, there is an elegant way of addressing it. Write the number 0 to n-1 in binary,  and rearrange them in order while reversing the order of their bits. Below shows an example of n=8.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{matrix}
input&amp; binary&amp; reversed &amp; output\\
0&amp; 000&amp; 000 &amp; 0\\ 
1&amp; 001&amp; 100&amp; 4\\
2&amp; 010&amp; 010&amp; 2\\
3&amp; 011&amp; 110&amp; 6\\
4&amp; 100&amp; 001&amp; 1\\
5&amp; 101&amp; 101&amp; 5\\
6&amp; 110&amp; 011&amp; 3\\
7&amp; 111&amp; 111&amp; 7\\
\end{matrix} %]]&gt;&lt;/script&gt;
</description>
      </item>
    
      <item>
        <title>二维格点随机游走问题</title>
        <link>http://localhost:4000/two-dimension-random-walk</link>
        <pubDate>Sat, 03 Jun 2017 00:00:00 +0800</pubDate>
        <author></author>
        <description>&lt;p&gt;一个粒子在二维空间中作随机运动，方向可以是上，下，左，右四种，且各方向等概，每一步步长为1. 假定从原点出发，以第n步时粒子所在位置到原点的距离作为半径画圆，计算这个圆的面积的期望。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;首先列出期望的两个性质：&lt;/p&gt;

&lt;h3 id=&quot;性质一&quot;&gt;性质一&lt;/h3&gt;

&lt;p&gt;任意函数\(\phi (x)\)，\(X\)为随机变量（以下简称\(r.v.\)），定义一个新的随机变量\(\phi (X)\). 如果\(\phi (X)\)具有有限的期望值，则：&lt;/p&gt;

&lt;p&gt;\[E(\phi (X))=\sum_k \phi (x_k)f(x_k)\]&lt;/p&gt;

&lt;p&gt;此处的级数绝对收敛当且仅当\(E(\phi (X))\)存在.&lt;/p&gt;

&lt;h3 id=&quot;性质二&quot;&gt;性质二&lt;/h3&gt;

&lt;p&gt;如果\(X_1,X_2,\cdots ,X_n\)都是具有有限期望值的\(r.v.\)，则它们的和的期望存在，且有：&lt;/p&gt;

&lt;p&gt;\[E(X_1+X_2+\cdots+X_n)=E(X_1)+E(X_2)+\cdots+E(X_n)\]&lt;/p&gt;

&lt;p&gt;这一性质对\(r.v.\)之间没有要求，也称为随机变量的线性性。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;&quot;&gt;William Feller&lt;/a&gt;在其 &lt;em&gt;An Introduction to Probability Theory and Its Application&lt;/em&gt; 一书中给出了使用联合分布的证明。&lt;/p&gt;

&lt;p&gt;只需考虑\(X,Y\)两个随机变量。&lt;/p&gt;

&lt;p&gt;\[E(X+Y)=\sum_{j,k}(x_j+y_k)P(X=x_j,Y=y_k)=\sum_{j,k}x_j P(X=x_j,Y=y_k)+\sum_{j,k}y_k P(X=x_j,Y=y_k)\]&lt;/p&gt;

&lt;p&gt;可以得到\(X\)的边缘分布:\(P(X=x_j)=\sum_kP(X=x_j,Y=y_k)\)，\(Y\)同理。&lt;/p&gt;

&lt;p&gt;即得到：\[L.H.S=\sum_jx_jP(X=x_j)+\sum_ky_kP(Y=y_k)=E(X)+E(Y)\]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;直接计算失败后，从递归的角度考虑得到了答案。递归的方法从第三部分开始。&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​	回到本题目，表征粒子运动的随机变量为它的坐标\((X,Y)\)，原题等价于求\(X^2+Y^2\)的期望。利用期望的第二个性质，可以分别求\(E(X^2)\)和\(E(Y^2)\)，再将它们相加得到结果。由于对称性，实际上只需求\(E(X^2)\)。&lt;/p&gt;

&lt;p&gt;考虑粒子横坐标\(r.v.\)的分布\(P(X=k)\).需要注意的是粒子在横轴上移动的步数也是\(r.v.\)（介于0到n之间）设为\(X’\)。当横轴坐标为k，移动步数为m时，有：&lt;/p&gt;

&lt;p&gt;\[P(X=k)=\sum_{m\ge 0}^nP(X=k, X’=m)\]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;上述写法其实有点问题，m并不能取到0～n中所有的值，因为粒子的运动是离散的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设粒子在横轴上沿着正方向移动了a个单位，负方向移动了b个单位则根据\(a+b=m,a-b=k\)可解出此情况下正方向移动的单位为\(\frac{m+k}{2}\)（需满足为整数）. 由于m步中每一步有两种选法，样本空间的大小为\(2^m\)；而m次中选了a次沿正向移动的情况有\(\binom{m}{\frac{m+k}{2}}\)种，故：&lt;/p&gt;

&lt;p&gt;\[P(X=k,X’=m)=\frac{\binom{m}{\frac{m+k}{2}}}{2^m}\]&lt;/p&gt;

&lt;p&gt;得到计算\(E(X^2)\)的总的表达式为：(由于对称性)&lt;/p&gt;

&lt;p&gt;\[E(X^2)=2\sum_{k=0}^nk^2\sum_{m\ge 0}^nP(X=k,X’=m)\]&lt;/p&gt;

&lt;p&gt;两个求和并非独立，第二个求和依赖于k的值。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;​	上述方法计算过于复杂，弃坑了。受到启发尝试使用递归的方法解决，发现出奇的简单。（递归大法好！）先列出走n步时的期望，以下标\(n\)记。&lt;/p&gt;

&lt;p&gt;\[E_n(X^2+Y^2)=\sum (x^2+y^2)P(X=x,Y=y)\]&lt;/p&gt;

&lt;p&gt;设此时到达\((x,y)\)。再走一步时，比如说横轴正方向再走一步到达\((x+1,y)\)概率为：&lt;/p&gt;

&lt;p&gt;\[P(X=x+1,Y=y)=P(X=x+1,Y=y|X=x,Y=y)P(X=x,Y=y)=\frac{1}{4}P(X=x,Y=y)\]&lt;/p&gt;

&lt;p&gt;同理对剩下的三个方向有类似的结果，则可以得到走\(n+1\)步时的所求期望：&lt;/p&gt;

&lt;p&gt;\[E_{n+1}(X^2+Y^2)=\frac{1}{4}\sum {[(x+1)^2+y^2]+[x^2+(y+1)^2]+[(x-1)^2+y^2]+[x^2+(y-1)^2]} P(X=x,Y=y)\]&lt;/p&gt;

&lt;p&gt;化简得到：&lt;/p&gt;

&lt;p&gt;\[E_{n+1}(X^2+Y^2)=\sum (x^2+y^2+1)P(X=x,Y=y)=E_n(X^2+Y^2)+\sum P(X=x,Y=y)\]&lt;/p&gt;

&lt;p&gt;后一项就是\(X,Y\)联合分布概率的归一，等于1！再根据边界条件\(E(0)=0\)得到&lt;/p&gt;

&lt;p&gt;\[E_{n}(X^2+Y^2)=n\]&lt;/p&gt;

&lt;p&gt;也就是说离散二维随机游走的距离平方的期望值就等于步数的大小！连续的情况其实也是类似，&lt;a href=&quot;https://en.wikipedia.org/wiki/Albert_Einstein&quot;&gt;A.Einstein&lt;/a&gt;曾经给出过布朗运动扩散的方均距离与时间的关系，即：&lt;/p&gt;

&lt;p&gt;\[\bar{l^2} \propto t\]&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>ssh-keygen实现密钥登录远程服务器</title>
        <link>http://localhost:4000/ssh-keygen</link>
        <pubDate>Mon, 29 May 2017 00:00:00 +0800</pubDate>
        <author></author>
        <description>&lt;p&gt;最近互联网上爆发了加密病毒，实验室的服务器疑似被入侵了。
最终定下来只使用一台32服务器连外网作为出口，另外两台通过32登录，且关闭ssh密码登录，转而使用ssh-keygen密钥实现自动登录。写篇短文以记录配置过程。
&lt;!--more--&gt;&lt;/p&gt;
&lt;h2 id=&quot;1首先在本地端生成rsa密钥和公钥&quot;&gt;1.首先在本地端生成RSA密钥和公钥&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh-keygen -t rsa
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后一路回车就可以了。（中间有设置密码提示，用来加密密钥）
会生成&lt;code class=&quot;highlighter-rouge&quot;&gt;id_rsa&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;is_rsa.pub&lt;/code&gt;两个文件，前者密钥保留在本地，公钥分配到需要登录的服务器上。&lt;/p&gt;
&lt;h2 id=&quot;2将ssh公钥上传到服务器&quot;&gt;2.将SSH公钥上传到服务器&lt;/h2&gt;
&lt;p&gt;只需要一条命令就行&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh-copy-id username@remote-server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;中间输入一次远程登录密码，SSH公钥就会自动上传了。公钥保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;/home/username/.ssh/authorized_keys&lt;/code&gt;文件中。之后使用ssh登录或者scp传输文件都不需要登录了。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>抛硬币先后手对胜率的影响</title>
        <link>http://localhost:4000/toss-coin-problem</link>
        <pubDate>Fri, 19 May 2017 00:00:00 +0800</pubDate>
        <author></author>
        <description>&lt;p&gt;最近复习概率论遇到一些很有意思的题目，有这样一个小例子：
\(A\)，\(B\)两人分别轮流抛一枚非公平硬币，正面朝上的概率是\(p\)，最先掷得正面朝上者胜出，假定\(A\)先抛，求先手胜出的概率。
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;可以证明，对于任意\(p&amp;gt;0\),先手获胜的概率都是大于\(\frac{1}{2}\)的。
甚至当硬币是公平的时候（\(p=0.5\)）先手获胜的概率仍然比二分之一要大。
在一种很极端的情况下，双方获胜概率趋近于相同，那就是硬币正面朝上的概率要趋于零（一个没有正面的硬币）！而此时双方都不可能获胜，这样的讨论在现实中也就失去了意义。&lt;/p&gt;

&lt;p&gt;下面先给出我的证明：
设\(A\)胜出的概率为\(P(A)\),\(B\)胜出的概率为\(P(B)\)，定义先手胜出的概率为\(P(win^{1st})\),在题目的条件下，\(A\)先手所以\(P(A)=P(win^{1st})\)
假设\(A\)第一次抛出了反面，我们就可以说\(B\)与\(A\)站在了同一起跑线上。在这种条件下\(B\)获胜的概率也就是我们所求的先手获胜概率。
由于\(A\)和\(B\)抛掷硬币是独立的，\(A\)第一次投出反面的情况下\(B\)获胜的概率为：
\[(1-p)P(win^{1st})=(1-p)P(A)\]
这个概率也等价于\(A\)没有获胜的概率，即\(P(\bar{A})\).
因此有：
\[(1-p)P(A)=1-P(A)\]
解出：\[P(A)=\frac{1}{2-p}\]&lt;/p&gt;

&lt;p&gt;这道题也可以用几何分布的模型来计算。
几何分布定义为在伯努利试验中，得到一次成功所需要的试验次数\(X\)。
若每次试验成功概率为\(p\)，那么\(k\)次试验中，第\(k\)次才得到成功的概率是：
\[P(X=k)=(1-p)^{k-1}p\]
在这题中若先抛者（也就是\(A\)）第\(k\)次抛掷硬币正面向上，意味着两人在之前交替的\(2(n-1)\)次中都抛出了反面，因此：
\[P(A)=\sum_{k=1}^{\infty}P(A_k)=\sum_{k=1}^{\infty}(1-p)^{2(n-1)}p=\frac{p}{1-(1-p)^2}=\frac{1}{2-p}\]&lt;/p&gt;

&lt;p&gt;对于这样一个看似周期性的过程，结果却与直觉相悖。由此观之，先手确实有着“得天独厚”的优势。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Courant Fischer定理的证明</title>
        <link>http://localhost:4000/courant-fischer-prove</link>
        <pubDate>Tue, 09 May 2017 00:00:00 +0800</pubDate>
        <author></author>
        <description>&lt;p&gt;对\(n\)阶实对称矩阵\(A\)有特征值\(\lambda_1\le \lambda_2\le \cdots\le \lambda_{n}\)，对应特征向量\(x_1,x_2,\cdots ,x_n\)，则对任意\(k\)维子空间\(V_k\)，有：&lt;/p&gt;

&lt;p&gt;\[\lambda_{n-k+1}=\max_{V_k}\min_{x\in V_k}\frac{x^TAx}{x^Tx}\]&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;这个定理得到在不同约束下的&lt;em&gt;Rayleigh&lt;/em&gt;商的极值。笔者最欣赏的证明出自于 &lt;a href=&quot;http://www-math.mit.edu/~gs/&quot;&gt;Gilbert Strang &lt;/a&gt;的 &lt;em&gt;Linear Algebra and Its Application&lt;/em&gt;，循序渐进由浅入深，为读者展现了解决问题的思考过程，读来颇有收获。在此整理一下，附上一些自己的理解。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;img src=&quot;/image/cupcakematrix.jpg&quot; alt=&quot;cupcake matrix&quot; /&gt;
&lt;p&gt;Gilbert Strang and his favourite -1, 2, -1 matrix&lt;/p&gt;
&lt;/div&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;lemma-1&quot;&gt;&lt;em&gt;Lemma 1&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Rayleigh’s Principle:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;\[\lambda_1\le R(x)=\frac{x^TAx}{x^Tx}\le \lambda_n\]&lt;/p&gt;

&lt;p&gt;当\(x=x_1\)时取到最小值；当\(x=x_n\)时取到最大值。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;proof:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;先从几何上理解一下Rayleigh商的含义，以最小化\(R(x)\)为例。令分子等于1得到\(n\)维超椭球的方程，这时候问题转变为最大化分母\(x^Tx=||x||^2\)。也就是找到一个方向（轴）使得在这个方向上超椭球面上的点到原点的距离最大（最长轴）。显然，沿着最长主轴(major axis)的方向就能得到\(R(x)\)的最小值，这个方向也很好通过\(A\)的相似对角化确定。&lt;/p&gt;

&lt;p&gt;\[R(x)=\frac{(Qy)^TA(Qy)}{(Qy)^T(Qy)}=\frac{y^T\Lambda y}{y^Ty}=\frac{\lambda_1y_1^2+\cdots +\lambda_ny_n^2}{y_1^2+\cdots +y_n^2}\]&lt;/p&gt;

&lt;p&gt;\(Q\)为正交阵，等价于进行有限次旋转和镜射，可以理解为将\(x\)在自然基下的坐标换到了\(A\)的特征向量基下。（注意上式中\(y_i\)表示坐标）由分子可以看出超椭球的主轴长度反比于\(\frac{1}{\sqrt \lambda}\), 因此最长主轴方向就是\(x_1\)的方向，在\(A\) 特征向量的基下坐标为\(y_1=1,y_2=0,\cdots ,y_n=0\).也可以利用不等式：&lt;/p&gt;

&lt;p&gt;\[\lambda_1(y_1^2+\cdots +y_n^2)\le \lambda_1y_1^2+\cdots\lambda_ny_n^2\]&lt;/p&gt;

&lt;p&gt;类似地可以求出在\(x_n\)方向上，\(R(x)\)取到极大值。实际上除了边界的特征向量为极值点, 中间的特征向量则是\(R(x)\)的鞍点(saddle points)。一个典型的鞍点：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;

&lt;img src=&quot;image/z=x^2-y^2.png&quot; alt=&quot;z=x^2-y^2&quot; style=&quot;zoom:70%&quot; /&gt;

&lt;p&gt;saddle point of z=x^2-y^2&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;鞍点的困难在于,对于一个特定的\(x\),我们不知道\(R(x)\)和那些中间的特征值\(\lambda_2,\cdots, \lambda_n\)的大小关系. 比如说我们想要让\(R(x)\)的最小值取到第\(j\)个特征值, 利用实对称矩阵的特征向量\(x_i\)相互正交的性质, 直接的想法是约束变量\(x\)取到与\(x_1,\cdots,x_{j-1}\)正交, 即\(x\)取值于子空间\(span\{x_j,\cdots,x_n\}\). 这样\(R(x)\)表达式中的\(y_1=\cdots=y_{j-1}=0\), Rayleigh 商也化为:&lt;/p&gt;

&lt;p&gt;\[\frac{\lambda_{j}y_j^2+\cdots+\lambda_ny_n^2}{y_j^2+\cdots+y_n^2}\]&lt;/p&gt;

&lt;p&gt;上式取到当\(y_j=1\)时取到最小值\(\lambda_j\).总结成引理二.&lt;/p&gt;

&lt;h3 id=&quot;lemma-2&quot;&gt;&lt;em&gt;Lemma 2&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;\[\lambda_j=\min R(x), \quad given\quad x^Tx_1=\cdots=x^Tx_{j-1}=0\]&lt;/p&gt;

&lt;p&gt;大部分时候\(A\)的特征向量是未知的, 也就是上述引理的约束不知道. 比如说我们考虑在不知道\(x_1\)的情况下得到\(R(x)\)和\(\lambda_2\)的关系. 这时我们使用任意一个向量\(z\)来代替\(x_1\). 当它们相等时, \(R(x)\)就能取到最小值\(\lambda_2\), 事实上就算在它们不相等的情况下, 我们可以得到:&lt;/p&gt;

&lt;p&gt;\[\lambda_2 = \max_z \min_{x^Tz=0}R(x)\]&lt;/p&gt;

&lt;p&gt;或用\(z\)的正交补\(V_{n-1}\)写作:&lt;/p&gt;

&lt;p&gt;\[\lambda_2= \max_{V_{n-1}} \min_{x \in V_{n-1}}R(x)\]&lt;/p&gt;

&lt;p&gt;&lt;em&gt;proof:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;任意给定\(z\), 存在\(\alpha, \beta\neq 0\) 使得\(x=\alpha x_1+\beta x_2\)与\(z\)正交. 一定存在这样的\(\alpha, \beta\)的原因是, 正交条件只给这两个变量施加了一个约束, 它们还保留一个自由度. 对任意满足该条件的组合:&lt;/p&gt;

&lt;p&gt;\[R(x)=\frac{\lambda_1 \alpha^2+\lambda_2 \beta^2}{\alpha^2+\beta^2}\le \lambda_2\]&lt;/p&gt;

&lt;p&gt;将上述定理推广, 即可得到&lt;em&gt;Courant Fischer&lt;/em&gt;定理, 下面给出证明.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;proof:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;对任意子空间\(V_{k}\in \Re^n\), 取\(x \in V_{k}\). 考虑\(V_{k}\)的正交补\(W_{n-k}\), 取定\(W_{n-k}\)的一组基\(w_1,\cdots, w_{n-k}\), \(x\)应满足分别垂直于这\(n-k\)个向量, 相当于对向量\(x\)施加了\(n-k\)个约束. 因此为了保证有解,在下面构造\(x\)的时候取了\(n-k+1\)个自由度.&lt;/p&gt;

&lt;p&gt;根据上述论述, 存在\(c_1,c_2,\cdots, c_{n-k+1}\)使得\(x=c_1 x_1+\cdots  c_{n-k+1}x_{n-k+1}\), 此时:&lt;/p&gt;

&lt;p&gt;\[R(x)=\frac{\lambda_1c_1^2+\cdots+\lambda_{n-k+1}c_{n-k+1}^2}{c_1^2+\cdots+c_{n-k+1}^2}\le\lambda_{n-k+1}\]&lt;/p&gt;

&lt;p&gt;容易验证当\(V_{k}=span\{x_{n-k+1},\cdots, x_{n}\}\)时, 上式取到最大值\(\lambda_{n-k+1}\).&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>git push repo 时保存密码的命令</title>
        <link>http://localhost:4000/git-push-save-pwd</link>
        <pubDate>Mon, 08 May 2017 00:00:00 +0800</pubDate>
        <author></author>
        <description>&lt;p&gt;在git push之前输一条命令可将密码保存到硬盘.&lt;/p&gt;
&lt;div class=&quot;language-terminal highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;git&lt;/span&gt;&lt;span class=&quot;kv&quot;&gt; config credential.helper store
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;密码保存在用户目录的.git-credentials文件中.&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>第一篇博文</title>
        <link>http://localhost:4000/First-post</link>
        <pubDate>Mon, 08 May 2017 00:00:00 +0800</pubDate>
        <author></author>
        <description>&lt;p&gt;经过再三斟酌和尝试之后，决定使用&lt;a href=&quot;https://pages.github.com&quot;&gt;github page&lt;/a&gt;和&lt;a href=&quot;http://jekyllcn.com/&quot;&gt;jekyll&lt;/a&gt;来建立自己的第一个博客。
&lt;!--more--&gt;
考虑到博客的维护问题和单纯的只是想记录一些想法写些文章的初心，就选择了一个足够简单纯粹且能够驾驭的框架和主题。&lt;/p&gt;

&lt;p&gt;现在只定下了一个初步的框架，以后也许会加入一些projects和paper reading也不定。&lt;/p&gt;

&lt;p&gt;总之一切顺着自己性子来;希望时间在此地缓缓流淌。&lt;/p&gt;
</description>
      </item>
    

  </channel>
</rss>
